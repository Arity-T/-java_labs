h1. Отчёт по лабораторной работе №2 (Тищенко Артём)

h2. Задание

* Исследовать *TreeSet*, посмотреть абстрактные классы и интерфейсы, которые данный тип реализует.
* Реализовать собственный класс *MyTreeSet*, который реализует интерфейсы *Iterable* и поддерживает основные операции множества: добавление, удаление, проверка наличия элемента, получение размера, а также итерацию по элементам в отсортированном порядке.
* Написать тесты, демонстрирующие аналогичное поведение стандартного *TreeSet* и реализованного класса.

h2. Исследование TreeSet

!treeset.png!

Класс *TreeSet* в Java реализует интерфейс *NavigableSet*, основанный на структуре данных **красно-черного дерева**. Он обеспечивает хранение элементов в отсортированном порядке и эффективное выполнение операций.

h3. Реализуемые интерфейсы:
* *NavigableSet*: Поддерживает навигацию по ближайшим элементам.
* *SortedSet*: Гарантирует порядок элементов согласно их естественному упорядочиванию.
* *Set*: Запрещает дублирование элементов.
* *Serializable*: Позволяет сериализацию объекта.
* *Cloneable*: Поддерживает клонирование.

h3. Основные характеристики:
* **Структура данных**: Красно-черное дерево (сбалансированное бинарное дерево поиска).
* **Время операций**: Добавление, удаление и поиск выполняются за *O(log n)*.
* **Порядок элементов**: Элементы хранятся в отсортированном порядке (natural ordering или через *Comparator*).
* **Итерация**: Итератор возвращает элементы в порядке возрастания.

h3. Недостатки:
* **Производительность**: Медленнее *HashSet* для операций добавления/удаления из-за необходимости поддержания баланса дерева.
* **Ограничения**: Элементы должны быть сравнимыми (реализовывать *Comparable*) или требовать внешнего *Comparator*.

h2. Реализация MyTreeSet

h3. Описание кода

Класс *MyTreeSet* реализует интерфейс *Iterable* и поддерживает основные операции множества с использованием **бинарного дерева поиска** (без балансировки). 

Основные методы:
* **add(E e)**: Добавляет элемент в дерево, сохраняя порядок. Возвращает *true*, если элемент был добавлен.
* **contains(E e)**: Проверяет наличие элемента в дереве.
* **remove(E e)**: Удаляет элемент, перестраивая дерево.
* **size()**: Возвращает количество элементов.
* **iterator()**: Возвращает итератор для обхода элементов в порядке возрастания (in-order traversal).

Поля класса:
* **root**: Корень дерева (тип *Node*).
* **size**: Текущее количество элементов.

Вспомогательные структуры:
* **Класс Node**: Содержит значение, ссылки на левое и правое поддерево.
* **Итератор**: Реализован через стек для симуляции рекурсивного in-order обхода.

h3. Тесты

Для проверки корректности работы *MyTreeSet* написаны следующие тесты:
* **testAdd**: Проверяет добавление элементов и обработку дубликатов.
* **testContains**: Проверяет поиск элементов.
* **testRemove**: Проверяет удаление элементов.
* **testSize**: Проверяет корректность подсчёта элементов.
* **testIterator**: Проверяет порядок обхода элементов и работу методов *hasNext()* и *next()*.

Каждый тест сравнивает поведение *MyTreeSet* со стандартным *TreeSet*.


h2. Результаты работы

*Исходный код доступен на "GitHub":https://github.com/Arity-T/java_labs/tree/main/lab2 .*

Склонировать репозиторий и запустить тесты можно с помощью команд:
<pre>
git clone https://github.com/Arity-T/java_labs.git
cd lab2
mvn test
</pre>

!tests.png!

h2. Заключение

В ходе работы был исследован класс *TreeSet* и реализован упрощённый аналог *MyTreeSet* на основе бинарного дерева поиска. Класс поддерживает основные операции множества и корректно работает с итератором. Тесты подтвердили соответствие поведения *MyTreeSet* стандартной реализации для базовых сценариев. Основное отличие — отсутствие балансировки дерева, что может влиять на производительность в худших случаях.

*Исходный код доступен на "GitHub":https://github.com/Arity-T/java_labs/tree/main/lab2 .*